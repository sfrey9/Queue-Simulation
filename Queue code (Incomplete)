# Summary:
#
# This program simulates the processing of customers at a ba
#
# notes: 
#
# In this model during each timestep a customer can leave the teller 
# and a new customer can approach the teller during the same time step.
# If the results don't match the provided results, change the events to
# consecutive rather than simultaneous.
#
# During the initial formulation redundant blocks/clauses were created to 
# expose errors. vestiges of the redundancies may exist in the final product.
# Check Thoroughly!! 
#
# Current model is messy and not-optimal. If there is time convert workspace
# into an OOP format. arrays are messy.
#
tellerstate = False; 
# the tellerstate is true if occupied, false if unnocupied.
tellertime = 0;
# teller time will equal the total amount of time the teller is 
# occupied. This should equal the sum of all the service times.
simulationon = True;
# simulationon takes False value when the last customer leaves.
simtime = 0;
# this will keep track of the total time the simulation has been running
tinterval = 0.1;
# the starting time is 0 and we proceed at intervals of 0.1 minutes.
c1 = [1, 3.2, 3.8, 0, 0,0,0,0,0];
c2 = [2, 10.9, 3.5, 0, 0,0,0,0,0];
c3 = [3, 13.2, 4.2, 0, 0,0,0,0,0];
c4 = [4, 14.8, 3.1, 0, 0,0,0,0,0];
c5 = [5, 17.7, 2.4, 0, 0,0,0,0,0];
c6 = [6, 19.8, 4.3, 0, 0,0,0,0,0];
c7 = [7, 21.5, 2.7, 0, 0,0,0,0,0];
c8 = [8, 26.3, 2.1, 0, 0,0,0,0,0];
c9 = [9, 32.1, 2.5, 0, 0,0,0,0,0];
c10 = [10, 36.6, 3.4, 0, 0,0,0,0,0];
# entry 1: Customer ID
# entry 2: Arrival time
# entry 3: Service time
# entry 4: Customer state. 0 if customer hasn't arrived
#                          1 if customer is in queue
#                          2 if customer is being served
#                          3 if customer has departed
# entry 5: Customer position in queue. 0 if customer not in queue.
# entry 6: Time of commencement of service
# entry 7: Departure time
# entry 8: Time in queue
# entry 9: Time in bank
allc = [c1,c2,c3,c4,c5,c6,c7,c8,c9,c10];
# thecustomers for the simulation are initialized we are now ready to start.
queue = 0;
# the initial length of the queue is 0 people.
servicecount = 0;
# counts the time spent being serviced

while simulationon == True:
    
        
    for i in range (0,10):
        
        # This block assigns new arrivals to either the teller
        # or the end of the queue depending on whether the teller
        # is occupied and if there's a queue.
        if allc[i][1] == simtime:
            if (tellerstate == False and queue == 0):
                allc[i][3] = 2;
                allc[i][5] = simtime;
                tellerstate = True;
            if (tellerstate == True):
                queue += 1;
                allc[i][4] = queue;
                allc[i][3] = 1;
                
        # This block checks if the customer at the teller is done. 
        # If so the customer is sent on their way.
        if (tellerstate == True and allc[i][3] == 2 and servicecount == allc[i][1]):
            tellerstate = False;
            allc[i][3] = 3;
            allc[i][6] = simtime;
            
        
    # This block checks if the teller is occupied and if he/she
    # isn't assigns the next person in the queue to the teller.
    if (tellerstate == False and queue >= 1):
        for i in range (0,10):
            if allc[i][4] == 1:
                allc[i][3] = 2;
                allc[i][5] = simtime;
                tellerstate = True;
            if allc[i][4] >= 1:
                allc[i][4] += -1;
                queue += -1;          
                
    
